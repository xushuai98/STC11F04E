C51 COMPILER V9.57.0.0   MAIN                                                              11/04/2019 22:23:29 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\MDK\install\Core\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg51.h>
   2          #include <intrins.h>
   3          #define uchar unsigned char
   4          #define uint unsigned int
   5          #define dec(dat) ((dat>>4)*10+(dat&0x0f))     // BCD码转十进制
   6          
   7          sbit IO = P1^4;         // DS1302 数据输入输出线
   8          sbit RST = P1^6;        // DS1302 复位信号线
   9          sbit SCLK = P1^5;       // DS1302 时钟信号线
  10          sbit DS = P1^7;         // DS18B20 数据端口
  11          sbit DAT = P3^0;        // 74HC164 数据输入端口
  12          sbit CLK = P3^1;        // 74HC164 时钟输入端口
  13          sbit DP = P3^7;         // 时间分割点
  14          sbit DP1 = P3^5;        // 温度小数点
  15          sbit KEY = P3^2;        // 按键INT0
  16          uint flag = 0;          // 时间小数点闪烁计数
  17          uint temp;              // 温度变量
  18          uint DISP_FLAG = 1;     // 功能显示标志位
  19          
  20          uchar code write_addr[]={0x80,0x82,0x84,0x86,0x88,0x8a,0x8c};   // DS1302写地址
  21          uchar code read_addr[]={0x81,0x83,0x85,0x87,0x89,0x8b,0x8d};    // DS1302读地址
  22          
  23          // 定义数码管段选(不加小数点0~9、℃)
  24          uchar code table1[]={0x81,0xD7,0xC8,0xC2,0x96,0xA2,0xA0,0xC7,0x80,0x82,0xA9};
  25          
  26          // 存储顺序是秒分时日月周年,存储格式是用BCD码
  27          uchar time[7]={0,0x55,0x18,0x04,0x10,0x05,0x19};  //初始化的时间为2019年10月4日18:55:00
  28          
  29          
  30          
  31          /**********************************************************
  32          *  函数名称：低精度延时函数
  33          *  日期：2019-9-7
  34          *  姓名：ZhangHJ
  35          *  说明：嵌套循环延时
  36          ***********************************************************/
  37          void delay(unsigned int mstime)
  38          {
  39   1        int i,j;
  40   1        for(i=mstime; i>=0; i--)
  41   1          for(j=114; j>=0; j--);
  42   1      }
  43          
  44          
  45          
  46          /**********************************************************
  47          *  函数名称：精确延时50ms函数
  48          *  日期：2019-10-25
  49          *  姓名：ZhangHJ
  50          *  说明：由STC-ISP自动生成
  51          ***********************************************************/
  52          void Delay50ms()    //@11.0592MHz
  53          {
  54   1        unsigned char i, j, k;
C51 COMPILER V9.57.0.0   MAIN                                                              11/04/2019 22:23:29 PAGE 2   

  55   1      
  56   1        _nop_();
  57   1        _nop_();
  58   1        i = 3;
  59   1        j = 26;
  60   1        k = 223;
  61   1        do
  62   1        {
  63   2          do
  64   2          {
  65   3            while (--k);
  66   3          } while (--j);
  67   2        } while (--i);
  68   1      }
  69          
  70          
  71          
  72          /**********************************************************
  73          *  函数名称：74HC164发送Byte数据函数
  74          *  日期：2019-9-29
  75          *  姓名：ZhangHJ
  76          *  说明：74HC164移位寄存器输入一字节数据发给寄存器
  77          ***********************************************************/
  78          void SendByte_74HC164(uchar byte)
  79          {
  80   1        uchar num,c;
  81   1        num=table1[byte];
  82   1        for(c=0; c<8; c++)
  83   1        {
  84   2          DAT=num&0x01;   // P3^0 --> 0000 000x
  85   2          CLK=0;          // 制造一个上升沿
  86   2          CLK=1;
  87   2          num>>=1;        // 将数据发送到寄存器
  88   2        }
  89   1      }
  90          
  91          
  92          
  93          /**********************************************************
  94          *  函数名称：DS18B20发送复位和初始化命令函数
  95          *  修改日期：2019-9-9
  96          *  修改人：ZhangHJ
  97          *  说明：1. 对于单片机: 单片机首先发出480-960us的低电平脉冲,
  98          *           释放总线为高电平(上拉电阻拉高),在随后的480us进行检测,
  99          *           如果出现低电平，说明器件应答正常.B
 100          *        2. 对于DS18B20: 上电后就检测是否有480/960us的低电平脉冲,
 101          *           如果有低电平,在总线释放之后，等待15-60us,
 102          *           将电平拉低60-240us,告诉主机已经准备好.
 103          ***********************************************************/
 104          uchar dsreset(void)         // send reset and initialization command
 105          {
 106   1        uint i;
 107   1        DS = 0;                   // 先将端口拉低
 108   1        i=120;                    // 维持低电平状态480us~960us
 109   1        while(i>0)i--;
 110   1        DS = 1;                   // 然后释放总线(将总线拉高),若DS18B20做出反应,将会将在15us~60us后将总线拉低
 111   1        // 等待DS18B20响应
 112   1        i = 0;
 113   1        while(DS)                 // 在DS高电平时等待
 114   1        {
 115   2          i++;
 116   2          if(i > 50000)           // 等待时间大于60us,说明响应失败
C51 COMPILER V9.57.0.0   MAIN                                                              11/04/2019 22:23:29 PAGE 3   

 117   2          {
 118   3            return 0;
 119   3          }
 120   2        }
 121   1        return 1;
 122   1      }
 123          
 124          
 125          
 126          /**********************************************************
 127          *  函数名称：DS18B20读1bit数据函数
 128          *  修改日期：2019-9-9
 129          *  修改人：ZhangHJ
 130          *  说明：1.首先单片机端口拉低 1 us (i++),
 131          *        2.然后释放总线,拉高总线,
 132          *        3.等待几位秒，是为了让 DS18B20 数据稳定,
 133          *        4.在15 us 内读取DS数据,
 134          *        5.接下来进行延时等待采样周期完成。
 135          *        详见DS18B20资料2.8.3.1读/写时间片
 136          ***********************************************************/
 137          bit tmpreadbit(void)        // read a bit data
 138          {
 139   1        uint i;
 140   1        bit dat;                  // 定义位数据 (dat = 0 or 1)
 141   1        DS = 0;                   // 先将端口拉低
 142   1        _nop_();                  // 延时 2us ,要求至少保持1us
 143   1        DS = 1;                   // 再将端口拉高
 144   1        i=8;while(i>0)i--;        // 等待DS数据稳定,要求的至少延时15us以上
 145   1        dat = DS;                 // 数据传输
 146   1        i=15;while(i>0)i--;       // 等待数据采样周期完成,要求不低于60us
 147   1        return (dat);
 148   1      }
 149          
 150          
 151          
 152          /**********************************************************
 153          *  函数名称：DS18B20读1Byte数据函数
 154          *  修改日期：2019-9-9
 155          *  修改人：ZhangHJ
 156          *  说明：1.首先初始化字节数据变量dat为 0
 157          *        2.循环 8 次,调用tmpreadbit函数,读 8bit 数据
 158          *        3.读出的数据暂存到 j ,之后进行移位和按位或操作
 159          *        4.效果是 j 先读入的数据,放到了dat的低位,读8次正好是1byte.
 160          *        5.最后返回读到的字节数据
 161          ***********************************************************/
 162          uchar tmpread(void)         // read a byte date
 163          {
 164   1        uchar i,j,dat;
 165   1        dat = 0;                  // 初始化数据变量为 0
 166   1        for(i=1;i<=8;i++)         // 循环 8 次,调用tmpreadbit函数,读 8bit 数据
 167   1        {
 168   2          j = tmpreadbit();       // 读出的数据暂存到 j
 169   2          dat = (j<<7)|(dat>>1);  // 效果是 j 先读入的数据,放到了dat的低位,读8次正好是1byte.
 170   2        }
 171   1        return(dat);              // 返回读到的字节
 172   1      }
 173          
 174          
 175          
 176          /**********************************************************
 177          *  函数名称：DS18B20写入1Byte数据函数
 178          *  修改日期：2019-9-11
C51 COMPILER V9.57.0.0   MAIN                                                              11/04/2019 22:23:29 PAGE 4   

 179          *  修改人：ZhangHJ
 180          *  说明：1.将对待写入数据dat进行位操作,将dat末位数值赋值给位数据testb
 181          *        2.通过判断testb得到写 0 还是写 1
 182          *        3.若是写 0 操作,将 DS 拉低,进行<60us的延时,再将DS拉高,进行>1us的延时
 183          *        4.若是写 1 操作,将 DS 拉低,进行>1us的延时,再将DS拉高,进行<60us的延时
 184          *        5.循环执行2、3、4操作8次,写入1字节数据
 185          *        详见18B20资料“2.8.3.1读/写时间片”章节
 186          ***********************************************************/
 187          void tmpwritebyte(uchar dat)   //write a byte to ds18b20
 188          {
 189   1        uint i;
 190   1        uchar j;
 191   1        bit testb;
 192   1        for(j=1;j<=8;j++)
 193   1        {
 194   2          testb = dat&0x01;
 195   2          dat = dat>>1;
 196   2          if(testb)                 // write 1
 197   2          {
 198   3            DS=0;
 199   3            i=8;while(i>0)i--;;     // 延时要求15~60us内
 200   3            DS=1;
 201   3            i=15;while(i>0)i--;     // 要求不低于60us
 202   3          }
 203   2          else
 204   2          {
 205   3            DS = 0;                 // write 0
 206   3            i=15;while(i>0)i--;
 207   3            DS = 1;
 208   3            i++;i++;
 209   3          }
 210   2        }
 211   1      }
 212          
 213          
 214          
 215          /**********************************************************
 216          *  函数名称：DS18B20温度转换函数
 217          *  修改日期：2019-9-11
 218          *  修改人：ZhangHJ
 219          *  说明：1.首先进行18B20初始化
 220          *        2.进行适当延时
 221          *        3.发送跳过光刻ROM指令
 222          *        4.发送RAM指令,进行温度转换
 223          *        详见18B20资料“2.8.3.1存储器操作命令”章节
 224          ***********************************************************/
 225          void tmpchange(void)          // DS18B20 begin change
 226          {
 227   1        while(dsreset() == 0)
 228   1        {
 229   2          SendByte_74HC164(0);
 230   2          P1 &= 0xfB;
 231   2        }
 232   1        delay(1);
 233   1        tmpwritebyte(0xCC);         // 跳过 ROM 操作
 234   1        tmpwritebyte(0x44);         // 启动一次温度转换
 235   1      }
 236          
 237          
 238          
 239          /**********************************************************
 240          *  函数名称：DS18B20温度转换完整过程函数
C51 COMPILER V9.57.0.0   MAIN                                                              11/04/2019 22:23:29 PAGE 5   

 241          *  修改日期：2019-9-11
 242          *  修改人：ZhangHJ
 243          *  说明：1.首先进行18B20初始化
 244          *        2.进行适当延时
 245          *        3.发送跳过光刻ROM指令
 246          *        4.发送RAM指令,进行温度转换
 247          *        5.读取两个8位数据,放到16位寄存器 temp 中
 248          *        6.将读取到的二进制数据(默认为正数),转换为十进制数据
 249          *        7.返回温度数据
 250          *        详见18B20资料“2.8.3.1存储器操作命令”章节
 251          ***********************************************************/
 252          uint tmp()                    // get the temperature
 253          {
 254   1        float tt;
 255   1        uchar high,low;
 256   1        //P1 |= 0x0f;
 257   1        while(dsreset() == 0)
 258   1        {
 259   2          SendByte_74HC164(0);
 260   2          P1 &= 0xfB;
 261   2        }
 262   1        delay(1);
 263   1        //tmpchange();
 264   1        tmpwritebyte(0xCC);         // 跳过 ROM 操作
 265   1        tmpwritebyte(0xBE);         // 读暂存寄存器
 266   1        low=tmpread();
 267   1        high=tmpread();
 268   1        temp=high;
 269   1        temp<<=8;                   // two byte compose a int variable
 270   1        temp=temp|low;
 271   1        tt=temp*0.0625;
 272   1        temp=tt*10+0.5;
 273   1        return temp;
 274   1      }
 275          
 276          
 277          
 278          /**********************************************************
 279          *  函数名称：数码管温度数据显示函数
 280          *  修改日期：2019-9-11
 281          *  修改人：ZhangHJ
 282          *  说明：1.temp表示需要显示的温度数值(百位数值)
 283          *        2.A1、A2、A3分别了百位、十位、个位数值
 284          *        3.控制段选信号dula和位选信号wela,以使数码管显示
 285          ***********************************************************/
 286          void Display_Tmp(uint temp)       // 显示程序
 287          {
 288   1        uchar A1,A2,A2t,A3,ser;
 289   1        ser=temp/10;
 290   1        SBUF=ser;
 291   1        A1=temp/100;                // A1 --> 百位
 292   1        A2t=temp%100;               // A2t --> 后两位
 293   1        A2=A2t/10;                  // A2 --> 十位
 294   1        A3=A2t%10;                  // A3 --> 个位
 295   1        
 296   1        DP1 = 0;                    // 温度小数点开启
 297   1        DP = 1;                     // 时间小数点关闭
 298   1         
 299   1        // 控制数码管显示温度数值
 300   1        P1 |= 0x0f;
 301   1        SendByte_74HC164(A1);
 302   1        P1 &= 0xfB;
C51 COMPILER V9.57.0.0   MAIN                                                              11/04/2019 22:23:29 PAGE 6   

 303   1        delay(6);
 304   1        P1 |= 0x0f;
 305   1        
 306   1        SendByte_74HC164(A2);
 307   1        P1 &= 0xfD;
 308   1        delay(6);
 309   1        P1 |= 0x0f;
 310   1        
 311   1        SendByte_74HC164(A3);
 312   1        P1 &= 0xfE;
 313   1        delay(6);
 314   1        P1 |= 0x0f;
 315   1        
 316   1        SendByte_74HC164(10);
 317   1        P1 &= 0xf7;
 318   1        delay(6);
 319   1        P1 |= 0x0f;
 320   1      }
 321          
 322          
 323          
 324          /**********************************************************
 325          *  函数名称：DS1302写操作函数
 326          *  日期：2019-10-4
 327          *  姓名：ZhangHJ
 328          *  说明：写操作包含两个参数,add表示要写入的地址;wdata表示要写入的数据
 329          *        1. 读写操作需要先将RST拉高才能进行
 330          *        2. 先写入控制字节,在时钟上升沿串行写入数据
 331          *        3. 再写入数据字节,同样在时钟上升沿写入数据
 332          *        4. 最后拉低RST禁止数据传输
 333          ***********************************************************/
 334          void DS1302Write(uchar add,uchar wdata)
 335          {
 336   1        uchar a;
 337   1        //wdata = hex(wdata);   // 转换为BCD码
 338   1        RST=0;                  // 拉低RST引脚,终止数据传输
 339   1        SCLK=0;                 // 拉低SCLK引脚,清零时钟线
 340   1        RST=1;                  // 拉高RST引脚,所有数据传输都要拉高RST脚,启动控制逻辑
 341   1        //先写入控制字节
 342   1        for(a=0; a<8; a++)
 343   1        {
 344   2            IO= add & 0x01;     // IO引脚准备好要写入的1位数据
 345   2            SCLK=1;             // SCLK上升沿,1位数据从IO脚写入,低位先写入
 346   2            add>>=1;            // 数据右移1位
 347   2            SCLK=0;             // 拉低SCLK,为下次写入准备,循环8次写入1字节
 348   2        }
 349   1        //再写入数据字节
 350   1        for(a=0; a<8; a++)
 351   1        {
 352   2            IO= wdata & 0x01;
 353   2            SCLK=1;
 354   2            wdata>>=1;
 355   2            SCLK=0;
 356   2        }
 357   1        RST=0;                  // 数据传输完拉低RST
 358   1      }  
 359          
 360          
 361          
 362          /**********************************************************
 363          *  函数名称：DS1302读操作函数
 364          *  日期：2019-10-4
C51 COMPILER V9.57.0.0   MAIN                                                              11/04/2019 22:23:29 PAGE 7   

 365          *  姓名：ZhangHJ
 366          *  说明：读操作只需一个参数,即需要读取的寄存器地址add
 367          *        1. 首先需要将需要读取的地址(1Byte)写入寄存器,在上升沿进行写入操作
 368          *        2. 之后读取该地址中的数据,在下降沿读取数据
 369          *        3. 最后返回读取到的1Byte数据
 370          ***********************************************************/ 
 371          uchar DS1302Read(uchar add)
 372          {
 373   1        uchar a, rdata=0;
 374   1        RST = 0;                      // 拉低RST引脚,终止数据传输
 375   1        SCLK = 0;                     // 拉低SCLK引脚,清零时钟线
 376   1        RST = 1;                      // 拉高RST引脚,启动控制逻辑
 377   1        //发送控制字节
 378   1        for(a=0; a<8; a++)
 379   1        {
 380   2          SCLK = 0;
 381   2          IO = add & 0x01;
 382   2          SCLK = 1;                   // 制造一个上升沿,写入地址
 383   2          add >>= 1;
 384   2        }
 385   1        //读1字节数据
 386   1        for(a=0; a<8; a++)
 387   1        {
 388   2          SCLK = 1;
 389   2          rdata >>= 1;
 390   2          SCLK = 0;                   // 制造一个下降沿,读取数据
 391   2          if(IO)
 392   2          {                           // 如果读到1
 393   3            rdata |= 0x80;            // 把最高位置为1,记录到rdata中
 394   3          }
 395   2        }
 396   1        RST=0;                        // 拉低RST
 397   1        //return dec(d);              // 读取的数据转换成十进制
 398   1        return rdata;
 399   1      }
 400          
 401          
 402          
 403          /**********************************************************
 404          *  函数名称：DS1302初始化函数
 405          *  日期：2019-10-4
 406          *  姓名：ZhangHJ
 407          *  说明：初始化即为对DS1302初始数据的写入
 408          *        1. 首先需要关闭写保护,以允许数据写入
 409          *        2. 之后按"秒分时日月周年"的顺序写入初始数据
 410          *        3. 最后开启写保护,禁止数据写入
 411          ***********************************************************/ 
 412          void ds1302_init()
 413          {
 414   1         uchar k;
 415   1         DS1302Write(0x8e,0x00);      // 禁止写保护，即允许数据写入
 416   1         for(k=0;k<7;k++)             // 写入7个字节的时钟信号：秒分时日月周年
 417   1         {
 418   2           DS1302Write(write_addr[k],time[k]);
 419   2         }
 420   1         DS1302Write(0x8e,0x80);      // 打开写保护,禁止数据写入
 421   1      }
 422          
 423          
 424          
 425          
 426          /**********************************************************
C51 COMPILER V9.57.0.0   MAIN                                                              11/04/2019 22:23:29 PAGE 8   

 427          *  函数名称：DS1302数据读取函数
 428          *  日期：2019-10-4
 429          *  姓名：ZhangHJ
 430          *  说明：数据读取即为按寄存器地址读取数据的过程
 431          *        直接按地址读取寄存器中的数据,然后将数据放到time数组里保存即可
 432          ***********************************************************/ 
 433          void read_time()
 434          {
 435   1         uchar n;
 436   1         for(n=0;n<7;n++)
 437   1          time[n]=DS1302Read(read_addr[n]);   //读取秒分时日月周年
 438   1      }
 439          
 440          
 441          
 442          /**********************************************************
 443          *  函数名称：数码管时间数据显示函数
 444          *  修改日期：2019-10-4
 445          *  修改人：ZhangHJ
 446          *  说明：1. A0~A9表示从秒到月的时间数值,按此规律可以计算到年
 447          *        2. DP表示时间分割的小数点,低电平选中
 448          *        3. 最后通过控制位选和段选点亮数码管,显示时间
 449          ***********************************************************/
 450          void Display_Time()             // 显示程序
 451          {
 452   1        uchar A0,A1,A2,A3,A4,A5,A6,A7,A8,A9;
 453   1        A0 = dec(time[0])/10;         // A0-->秒十位
 454   1        A1 = dec(time[0])%10;         // A1-->秒个位
 455   1        A2 = dec(time[1])/10;         // A2-->分十位
 456   1        A3 = dec(time[1])%10;         // A3-->分个位
 457   1        A4 = dec(time[2])/10;         // A4-->时十位
 458   1        A5 = dec(time[2])%10;         // A5-->时个位
 459   1        A6 = dec(time[3])/10;         // A6-->日十位
 460   1        A7 = dec(time[3])%10;         // A7-->日个位
 461   1        A8 = dec(time[3])/10;         // A8-->月十位
 462   1        A9 = dec(time[3])%10;         // A9-->月个位
 463   1        
 464   1        DP1 = 1;                      // 温度小数点关闭
 465   1        flag ++;                      // 时间点闪烁计数
 466   1        if(flag >= 134)
 467   1        {
 468   2          DP = ~DP;
 469   2          flag = 0;
 470   2        }
 471   1         
 472   1        // 控制数码管显示温度数值
 473   1        P1 |= 0x0f;
 474   1        SendByte_74HC164(A4);         // A4-->时十位
 475   1        P1 &= 0xf7;
 476   1        delay(6);
 477   1        P1 |= 0x0f;
 478   1        
 479   1        SendByte_74HC164(A5);         // A5-->时个位
 480   1        P1 &= 0xfB;
 481   1        delay(6);
 482   1        P1 |= 0x0f;
 483   1        
 484   1        SendByte_74HC164(A2);         // A2-->分十位
 485   1        P1 &= 0xfd;
 486   1        delay(6);
 487   1        P1 |= 0x0f;
 488   1        
C51 COMPILER V9.57.0.0   MAIN                                                              11/04/2019 22:23:29 PAGE 9   

 489   1        SendByte_74HC164(A3);         // A3-->分个位
 490   1        P1 &= 0xfe;
 491   1        delay(6);
 492   1        P1 |= 0x0f;
 493   1      }
 494          
 495          
 496          /**********************************************************
 497          *  函数名称：配置外部中断0
 498          *  日期：2019-10-22
 499          *  姓名：ZhangHJ
 500          *  说明：1. 选择为下降沿触发方式(为1代表下降沿触发，为0代表低电平触发)
 501          *    2. 使能外部中断0
 502          *      3. 使能总中断
 503          ***********************************************************/
 504          void configExtInt0()
 505          {
 506   1        IT0 = 1;  //选择为下降沿触发方式(为1代表下降沿触发，为0代表低电平触发)
 507   1        EX0 = 1;  //使能外部中断0
 508   1        EA = 1;   //使能总中断
 509   1      }
 510          
 511          
 512          /**********************************************************
 513          *  函数名称：外部中断0服务函数
 514          *  日期：2019-11-4
 515          *  姓名：ZhangHJ
 516          *  说明：中断服务函数功能为,使功能显示标志位 DISP_FLAG 循环切换
 517          ***********************************************************/
 518          void extInt0() interrupt 0
 519          {
 520   1        EA = 0;             // 关闭总中断
 521   1        Delay50ms();        // 延时防抖
 522   1        if(KEY == 0)
 523   1        {
 524   2          P1 |= 0x0f;       // 关闭位选,清屏
 525   2          DISP_FLAG = ~DISP_FLAG;   // 显示其他功能
 526   2        }
 527   1        EA = 1;             // 开启总中断
 528   1      }
 529          
 530          
 531          
 532          // 主函数功能：默认显示时间(初始化时间为“2019年10月4日18:55:00”),按住INT0按键时,会显示温度
 533          void main()
 534          {
 535   1        uchar a;
 536   1        configExtInt0();                  // 配置外部中断0
 537   1        ds1302_init();                    // DS1302日期初始化
 538   1        while(1)
 539   1        {
 540   2          if(DISP_FLAG == 1)              // 时间显示
 541   2          {
 542   3            read_time();                  // DS1302读取当前时间
 543   3            Display_Time();               // 显示当前时间
 544   3          }
 545   2          else                            // 温度显示
 546   2          {
 547   3              tmpchange();                // 温度转换
 548   3              for(a=40;a>0;a--)           // 延时,保持连续显示
 549   3              {
 550   4                Display_Tmp(tmp());       // 进行温度转换和数值显示
C51 COMPILER V9.57.0.0   MAIN                                                              11/04/2019 22:23:29 PAGE 10  

 551   4              }
 552   3          }
 553   2        }
 554   1      }
 555          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1115    ----
   CONSTANT SIZE    =     25    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13      14
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
